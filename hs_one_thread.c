// PICTURE OF ME

/*⠀
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠋⠉⠈⠉⠉⠉⠉⠛⠻⢿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣿⣿
⣿⣿⣿⣿⡏⣀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿
⣿⣿⣿⢏⣴⣿⣷⠀⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿
⣿⣿⣟⣾⣿⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣷⢢⠀⠀⠀⠀⠀⠀⠀⢸⣿
⣿⣿⣿⣿⣟⠀⡴⠄⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⣿
⣿⣿⣿⠟⠻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠶⢴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣿
⣿⣁⡀⠀⠀⢰⢠⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⡄⠀⣴⣶⣿⡄⣿
⣿⡋⠀⠀⠀⠎⢸⣿⡆⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⠗⢘⣿⣟⠛⠿⣼
⣿⣿⠋⢀⡌⢰⣿⡿⢿⡀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⡇⠀⢸⣿⣿⣧⢀⣼
⣿⣿⣷⢻⠄⠘⠛⠋⠛⠃⠀⠀⠀⠀⠀⢿⣧⠈⠉⠙⠛⠋⠀⠀⠀⣿⣿⣿⣿⣿
⣿⣿⣧⠀⠈⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠀⠀⠀⠀⢀⢃⠀⠀⢸⣿⣿⣿⣿
⣿⣿⡿⠀⠴⢗⣠⣤⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡸⠀⣿⣿⣿⣿
⣿⣿⣿⡀⢠⣾⣿⠏⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠉⠀⣿⣿⣿⣿
⣿⣿⣿⣧⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿
⣿⣿⣿⣿⡄⠈⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣦⣄⣀⣀⣀⣀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠙⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠁⠀⠀⠹⣿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⠿⠛⠉⠉⠁⠀⢻⣿⡇⠀⠀⠀⠀⠀⠀⢀⠈⣿⣿⡿⠉⠛⠛⠛⠉⠉
⣿⡿⠋⠁⠀⠀⢀⣀⣠⡴⣸⣿⣇⡄⠀⠀⠀⠀⢀⡿⠄⠙⠛⠀⣀⣠⣤⣤⠄⠀
*/

// INCLUDES:

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <math.h>
#include <string.h>
#include <unistd.h>

// GLOBALS:

pthread_mutex_t mutex_lock;  // mutually exclusive lock for threads
int* ready_g;  // global ready states for threads
int* input_g; // global input array
int* sums_g;  // global prefix sum array
int* mid_sums_g;  // global sum in between steps array
int size_g;  // global size of input
int nt_g;  // global number of threads

// FUNCTIONS:

int calculateLoops(int tn, int jump)
{  // calculate how many loops thread (tn) needs to take this step
	int R = 0;  // return value
	int jumps_left = (size_g - jump);

	while(jumps_left > nt_g)
	{
		{  // figure out how many loops this thread needs to take
			R++;
			jumps_left -= nt_g;
		}
	}
	if(jumps_left >= tn)
	{
		R++;
	}

	return R;
}

void printSums()
{
	for(int i = 0; i < size_g; i++)
	{
		printf("%d\n", sums_g[i]);
	}
}

int allThreadsReady()
{
	int R = 0;  // return value
	
	for(int i = 0; i < nt_g; i++)
	{
		if(!ready_g[i])
		{  // if a thread is not ready
			R = 0;
			break;
		}
	}

	return R;
}

void* threadFunction(void* par)
{
	int tn = *((long*) par);  // thread number
	int step = 0;  // step/row counter
	int jump = 1;  // how many numbers to jump forward to calculate current sum, start at 1 because 2^0 = 1
	int loops = 0;  // total loops this thread needs to perform this step

	while(jump < size_g)
	{  // while there is another sum to be calculated
		printf("new while in thread%d\n", tn);
		loops = calculateLoops(tn, jump);
		for(int i = 0; i < loops; i++)
		{  // add input values
			mid_sums_g[jump + (tn - 1) + (i * nt_g)] = (input_g[jump + i] + input_g[i]);
		}
		ready_g[tn] = 1;
		printf("*** thread%d ready to move on\n", tn);
		while(allThreadsReady)
		{
			sleep(0.1);
		}  // barrier
		ready_g[tn] = 0;

		memcpy(input_g, mid_sums_g, sizeof(mid_sums_g));
		step++;	
		jump = pow(2, step);
	}
	for(int i = 0; i < jump; i++)
	{  // set values in prefix sum array
		printf("thread%d sets sums[%d] to %d\n", tn, i, input_g[i]);
		sums_g[i] = input_g[i];
	}
	
	return 0;
}

/*
	input = int array
	size = size of input
	nt = number of threads
*/
void production(int* input, int size, int nt)
{
	pthread_t threads[nt];  // array to store thread
	int tn[nt];

	for(int i = 0; i < nt; i++)
	{  // create (nt) threads
		tn[i] = (i + 1);
		pthread_create(&threads[i], NULL, threadFunction, (void*) &tn[i]);
		printf("thread%d created\n", tn[i]);
	}
	for(int i = 0; i < nt; i++)
	{  // wait for all threads to finish executing
		pthread_join(threads[i], NULL);
	}
	printSums();

	return;
}

int main()
{
	int input[5] = {1, 2, 3, 4, 5};  // input array
	int size = 5;  // size of input array
	int nt = 2;  // number of threads
	int sums[size];  // array of prefix sums
	int ready[nt];  // array of booleans for if each thread is ready to move on

	ready_g = ready;  // make ready global
	input_g = input;  // make input global
	sums_g = sums;  // make sums global
	mid_sums_g = input;  // make mid_sums global
	memcpy(mid_sums_g, input, sizeof(input));
	size_g = size;  // make size global
	nt_g = nt;  // make nt global

	for(int i = 0; i < nt; i++)
	{  // initialize ready_g
		ready_g[i] = 0;  // by default, threads aren't ready to move on yet
	}

	production(input, size, nt);

	return 0;
}
