// PICTURE OF TA GUIN

/*⠀
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠋⠉⠈⠉⠉⠉⠉⠛⠻⢿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣿⣿
⣿⣿⣿⣿⡏⣀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿
⣿⣿⣿⢏⣴⣿⣷⠀⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿
⣿⣿⣟⣾⣿⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣷⢢⠀⠀⠀⠀⠀⠀⠀⢸⣿
⣿⣿⣿⣿⣟⠀⡴⠄⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⣿
⣿⣿⣿⠟⠻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠶⢴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣿
⣿⣁⡀⠀⠀⢰⢠⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⡄⠀⣴⣶⣿⡄⣿
⣿⡋⠀⠀⠀⠎⢸⣿⡆⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⠗⢘⣿⣟⠛⠿⣼
⣿⣿⠋⢀⡌⢰⣿⡿⢿⡀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⡇⠀⢸⣿⣿⣧⢀⣼
⣿⣿⣷⢻⠄⠘⠛⠋⠛⠃⠀⠀⠀⠀⠀⢿⣧⠈⠉⠙⠛⠋⠀⠀⠀⣿⣿⣿⣿⣿
⣿⣿⣧⠀⠈⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠀⠀⠀⠀⢀⢃⠀⠀⢸⣿⣿⣿⣿
⣿⣿⡿⠀⠴⢗⣠⣤⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡸⠀⣿⣿⣿⣿
⣿⣿⣿⡀⢠⣾⣿⠏⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠉⠀⣿⣿⣿⣿
⣿⣿⣿⣧⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿
⣿⣿⣿⣿⡄⠈⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣦⣄⣀⣀⣀⣀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠙⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠁⠀⠀⠹⣿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⠿⠛⠉⠉⠁⠀⢻⣿⡇⠀⠀⠀⠀⠀⠀⢀⠈⣿⣿⡿⠉⠛⠛⠛⠉⠉
⣿⡿⠋⠁⠀⠀⢀⣀⣠⡴⣸⣿⣇⡄⠀⠀⠀⠀⢀⡿⠄⠙⠛⠀⣀⣠⣤⣤⠄⠀
*/

// INCLUDES:

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <math.h>
#include <string.h>
#include <unistd.h>

// GLOBALS:

pthread_mutex_t mutex_lock;  // mutually exclusive lock
int* input_g;  // global input
int* mid_g;  // global sums in the middle of each step
int* sums_g;  // global prefix sums array
int size_g;  // global size
int nt_g;  // global number of threads
int t_ready_g = 0;  // number of threads ready to move on

// FUNCTIONS:

int calculateLoops(int tn, int jump)
{  // calculate how many loops thread (tn) needs to take this step
	int R = 0;  // return value
	int jumps_left = (size_g - jump);

	while(jumps_left > nt_g)
	{
		{  // figure out how many loops this thread needs to take
			R++;
			jumps_left -= nt_g;
		}
	}
	if(jumps_left >= tn)
	{
		R++;
	}

	return R;
}

void printSums()
{
	for(int i = 0; i < size_g; i++)
	{
		printf("%d\n", sums_g[i]);
	}
}

void* threadFunction(void* arg)
{
	int tn = *((long*) arg);  // this thread's number
	int step = 1;  // step/row counter
	int jump = 1;  // jump size for this step, first jump is 2^0 = 1
	int loops;  // how many loops this thread needs to take this loop
	int input_set = 0;  // counter for if input has been set this loop
	int index;  // variable to decrease overall calculations

	printf("thread%d in threadFunction\n", tn);
	while(jump < size_g)
	{	
		printf("!! thread%d: jump = %d\n", tn, jump);
		loops = calculateLoops(tn, jump);
		for(int i = 0; i < loops; i++)
		{  // counts loops
			index = (jump + (tn - 1) + (i * nt_g));
			printf("thread%d: mid[%d] = (input[%d]) %d + (input[%d]) %d\n", tn, index, index, input_g[index], (index - jump), input_g[index - jump]); fflush(stdout);
			printf("thread%d: this is input[1] -> %d\n", input_g[1]);
			mid_g[index] = (input_g[index] + input_g[index - jump]);
		}
		t_ready_g++;  // thread is ready to move on
		while(t_ready_g < (step * nt_g));  // barrier
		printf("-> thread%d: moving on\n", tn); fflush(stdout);
		pthread_mutex_lock(&mutex_lock);  // lock
		if(input_set < step)
		{
			printf("** thread%d: copying mid to input\n", tn); fflush(stdout);
			memcpy(input_g, mid_g, (size_g * sizeof(int)));
			input_set++;
		}
		pthread_mutex_unlock(&mutex_lock);
		step++;
		jump = (1 << (step - 1));
	}
	for(int i = 0; i < jump; i++)
	{  // set values in prefix sum array
		if(sums_g[i] != input_g[i])
		{
			//printf("thread%d sets sums[%d] to %d\n", tn, i, input_g[i]);
			sums_g[i] = input_g[i];
		}
	}

	printf("thread%d exiting threadFunction\n", tn);
	return 0;
}

void production(int* input, int size, int nt)
{
	pthread_t threads[size_g];
	int tn[nt_g];  // array to store thread numbers (ids)

	for(int i = 0; i < nt; i++)
	{  // create (nt) threads
		tn[i] = (i + 1);  // assign id to each thread
		pthread_create(&threads[i], NULL, threadFunction, (void*) &tn[i]);
	}
	for(int i = 0; i < nt; i++)
	{  // wait for all threads to finish executing
		pthread_join(threads[i], NULL);
	}
	printSums();
}

int main()
{
	int input[4] = {1, 2, 3, 4};  // input array
	int size = 4;  // size of input array
	int nt = 2;  // number of threads
	int sums[size];
	int mid[size];

	input_g = input;
	size_g = size;
	nt_g = nt;
	sums_g = sums;
	mid_g = mid;
	memcpy(mid_g, input_g, (size_g * sizeof(int)));  // set mid_g to input
	memcpy(sums_g, input_g, (size_g * sizeof(int)));  // set sums_g to input

	production(input, size, nt);

	return 0;
}
